%!TEX root = latex/refman.tex

\chapter{Exemplos}

As estruturas foram testadas utilizando o arquivo \texttt{main.cpp}, documentado na seção anterior. abaixo é apresentado o \emph{log} comentado do programa. Todas as estruturas receberam nomes, os quais são exibidos quando elas são testadas.

Abaixo é apresentado o resultado dos testes de inserção e remoção de dados nas pilas e filas, tanto dinâmicas quanto estáticas. Não é esperada nenhuma exceção. Todas as estruturas apresentaram o comportamento esperado. Quando a estrutura alcança um tamanho múltiplo de 10, uma observação sem remoção é feita, apresentada como valores entre colchetes.

\begin{verbatim}
************************
Teste de estruturas de dados
Valores entre colchetes representam consultas sem remoção
*********************

Inserindo 15 valores na pilha de tipo Static Stack...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
Removendo valores da pilha...
15 14 13 12 11 [10] 10 9 8 7 6 5 4 3 2 1
Inserindo 15 valores na fila de tipo Static Queue...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
Removendo valores da fila...
1 2 3 4 5 [6] 6 7 8 9 10 11 12 13 14 15
Inserindo 40 valores na pilha de tipo Dynamic Stack...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
Removendo valores da pilha...
[40] 40 39 38 37 36 35 34 33 32 31 [30] 30 29 28 27 26 25 24 23 22 21 [20] 20 19 18 17 16 15 14 13 12 11 [10] 10 9 8 7 6 5 4 3 2 1
Inserindo 40 valores na fila de tipo Dynamic Queue...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
Removendo valores da fila...
[1] 1 2 3 4 5 6 7 8 9 10 [11] 11 12 13 14 15 16 17 18 19 20 [21] 21 22 23 24 25 26 27 28 29 30 [31] 31 32 33 34 35 36 37 38 39 40
\end{verbatim}

A seguir são apresentados os testes na lista encadeada e na lista ordenada. O objetivo final é que ambas as listas possuam os números de 1 a 6 ordenados dentro de si. Na lista encadeada, os dados são inseridos fora de ordem, prontificando o uso da inserção em posições da estrutura para que a ordenação seja garantida. Já na lista ordenada, os dados também são inseridos fora de ordem, mas a estrutura ordena-os sem necessitar da passagem explícita da posição de cada um. Posteriormente, os dados de ambas as listas são removidos em posições aleatórias.

\begin{verbatim}
Inserindo valores na lista do tipo Linked List...
Valores: [2 5 4 1 6 3]
Posição: [0 1 1 0 4 2]
2
2 5
2 4 5
1 2 4 5
1 2 4 5 6
1 2 3 4 5 6

Removendo valores da lista...
1 2 3 4 6
1 3 4 6
1 3 4
1 4
1


Inserindo valores na lista do tipo Ordered List...
Valores: [2 4 6 1 3 5]
Posição: [0 1 2 3 4 5]
2
2 4
2 4 6
1 2 4 6
1 2 3 4 6
1 2 3 4 5 6

Removendo valores da lista...
1 2 3 4 6
1 3 4 6
1 3 4
1 4
1
\end{verbatim}

Por último, foram testadas as situações de \emph{underflow} e \emph{overflow} nas devidas estruturas. O \emph{overflow} foi testado tentado-se inserir 18 elementos em filas e pilhas estáticas de tamanho máximo 17, prontificando uma mensagem de erro. O \emph{underflow} foi testado em todas as estruturas, tentando-se remover 5 elementos quando todas as estruturas possuíam 3 elementos. No caso das listas, foi efetuada a remoção do elemento na posição 0 até que o programa apresentasse uma exceção expondo que o índice não existia.

\begin{verbatim}
=============================================================
= Testando underflow nas estruturas de tamanho pré-definido =
=============================================================
Inserindo 18 valores na pilha de tipo Static Stack...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Ocorreu um erro: The stack is full.

Inserindo 18 valores na fila de tipo Static Queue...
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Ocorreu um erro: The queue is full.

=====================================
= Testando underflow nas estruturas =
=====================================
Ocorreu um erro: The stack is empty.
Ocorreu um erro: The stack is empty
Ocorreu um erro: The queue is empty.
Ocorreu um erro: The queue is empty
Ocorreu um erro: Nonexistent index in list.
Ocorreu um erro: Nonexistent index in list.
\end{verbatim}

\chapter{Conclusão}

Este trabalho apresentou a implementação de diversas estruturas de dados na linguagem C++ utilizando uma série de artifícios disponibilizados pela linguagem. Pilhas e filas de tamanho estático foram criadas utilizando vetores primitivos para armazenamento de dados; uma lista duplamente encadeada foi criada utilizando alocação dinâmica de memória, a qual permitiu a implementação de pilhas e filas de tamanho váriável através de herança. A lista duplamente encadeada também serviu de base para a criação de uma lista ordenada.

Graças à herança e ao polimorfismo, estruturas de dados de mesma super-classe puderam ser testadas nas mesmas funções de teste. Situações de \emph{underflow} e \emph{overflow} foram gerenciadas através da criação e tratamentos de exceções. Todas as estruturas são capazes de armazenar qualquer tipo de dados, graças ao uso dos \emph{templates} em C++.

Por último, as estruturas criadas foram testadas, demonstrando o comportamento e métodos específicos de cada uma, assim como as situações de exceção. 
